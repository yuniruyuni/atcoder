use proconio::input;

fn main() {
    input! {
        n: usize,
    }

    // n = 7で具体的に考えてみる。
    // a = 7 のとき ありえない (これはいつでも。よってaの範囲は 0 < a < n)
    // a = 6 のとき n = 1*a + 1 のいずれか
    // a = 5 のとき n = 1*a + 2 のいずれか
    // a = 4 のとき n = 1*a + 3 のいずれか
    // a = 3 のとき n = 2*a + 1 = 1*a + 4 のいずれか
    // a = 2 のとき n = 3*a + 1 = 2*a + 3 = 1*a + 5 のいずれか
    // → ここまでは max_bで単にカウントダウンしたら良かった。
    // a = 1 のとき n = 6*a + 1 = 5*a + 2 = 4*a + 3 = 3*a + 4 = 2*a + 5 = 1*a + 6 のいずれか
    // → a = 1のときだけ法則が乱れる。n/1が0だから。これは多分約数一般に同じ？
    // 1以外の約数が存在するモノということで、n = 4で具体的に考える
    // a = 4 ない
    // a = 3 のとき n = 1*a + 1
    // a = 2 のとき n = 1*a + 2 ← やはり剰余がないときに法則が乱れる(1つ可能性が減るっぽい)
    // a = 1 のとき n = 3*a + 1 = 2*a + 2 = 1*a + 3

    let mut ans = 0;
    for a in 1..n {
        let max_b = n / a;
        let rem = if n % a == 0 { 1 } else { 0 };
        ans += max_b - rem;
    }

    println!("{}", ans);
}
